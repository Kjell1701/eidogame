<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>RetroRunner — Mobile-first Prototype (EIDEO)</title>
  <meta name="description" content="RetroRunner — Mobile/Tablet-first Jump-Runner Prototype für die EIDEO Schule" />
  <style>
    /* Mobile-first, fullscreen canvas app styling */
    :root{--bg:#071028;--panel:rgba(255,255,255,0.02);--accent:#ffd166;--muted:#9aa6b2}
    html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, 'Helvetica Neue', Arial;background:var(--bg);color:#fff;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}
    .app{width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center}

    /* Canvas fills the available safe area; keep aspect ratio */
    .canvas-wrap{width:100%;max-width:1100px;aspect-ratio:16/9;position:relative}
    canvas{display:block;width:100%;height:100%;border-radius:12px;background:#8db4ff;touch-action:manipulation}

    /* Minimal HUD overlay - mobile friendly */
    .hud{position:absolute;left:0;right:0;top:6px;display:flex;flex-direction:column;align-items:center;pointer-events:none}
    .highscore{font-size:12px;color:#fff;opacity:0.95;margin-bottom:6px;background:rgba(0,0,0,0.25);padding:4px 10px;border-radius:999px}
    .distance{font-weight:800;font-size:28px;letter-spacing:1px;color:#fff;background:rgba(0,0,0,0.32);padding:8px 16px;border-radius:999px}

    /* Start/Overlay screens */
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;padding:20px}
    .start-top{position:absolute;top:18px;left:0;right:0;display:flex;flex-direction:column;align-items:center;pointer-events:none}
    .title{font-size:20px;font-weight:800;margin:0}
    .subtitle{font-size:12px;opacity:0.9;margin-top:4px}
    .start-bottom{position:absolute;left:0;right:0;bottom:18px;display:flex;align-items:center;justify-content:center}
    .start-prompt{color:#fff;background:rgba(0,0,0,0.28);padding:8px 14px;border-radius:999px;font-weight:700}

    .end-panel{background:rgba(7,16,40,0.6);backdrop-filter:blur(4px);padding:16px;border-radius:12px;text-align:center}
    .small{font-size:13px;opacity:0.95;margin-top:8px}

    @media (min-width:900px){ .canvas-wrap{max-width:900px} }
  </style>
</head>
<body>
  <div class="app">
    <div class="canvas-wrap">
      <canvas id="game"></canvas>

      <div class="hud" id="hud">
        <div class="highscore" id="highscore">Highscore: 0</div>
        <div class="distance" id="distance">0 m</div>
      </div>

      <!-- START overlay: title top, prompt bottom (tap anywhere to start) -->
      <div id="startOverlay" class="overlay" style="pointer-events:auto">
        <div class="start-top">
          <h1 class="title">RetroRunner</h1>
          <div class="subtitle">Schulretrospiel</div>
        </div>
        <div class="start-bottom">
          <div class="start-prompt">Tippe zum Starten</div>
        </div>
      </div>

      <!-- END overlay: shows on game over or win, tap anywhere to restart -->
      <div id="endOverlay" class="overlay" style="display:none;pointer-events:auto;">
        <div class="end-panel" id="endPanel">
          <h2 id="endTitle" style="margin:0">Game Over</h2>
          <p id="endText" class="small">Distanz: 0 m</p>
          <div style="height:8px"></div>
          <div class="small">Tippe auf den Bildschirm, um zu starten</div>
        </div>
      </div>

    </div>
  </div>

<script>
// ------------------------------------------------------
// RetroRunner — Mobile-first runner prototype (mobile UX tweaks requested)
// Changes included:
// - Start screen: title top + 'Tippe zum Starten' bottom, tap anywhere to start
// - End screen: no buttons, tap anywhere to restart; text localized
// - Obstacles now sit on the ground and are scene-aware (cars in Straße, backpacks/people in Schulflur)
// - Collision distinguishes landing on top (no death) vs. side/front collision (death)
// - Player drawn as classic stickman (stroke-only head, thin limbs)
// ------------------------------------------------------

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  const DPR = Math.min(window.devicePixelRatio || 1, 2);
  canvas.width = Math.round(rect.width * DPR);
  canvas.height = Math.round(rect.height * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// ----------------- CONFIG -----------------
const CONFIG = {
  START_SPEED: 3.8,
  SPEED_INCREASE_PER_500M: 0.6,
  GRAVITY: 1,
  JUMP_FORCE: -14,
  WIN_DISTANCE: 5000,
  GROUND_HEIGHT: 90,
  PLAYER: {x:110, w:28, h:42},
  OBSTACLE_MIN_INTERVAL: 55,
  OBSTACLE_MAX_INTERVAL: 140,
  DEBUG: false
};

// ----------------- State -----------------
let W = 16/9 * 450; let H = 450;
let groundY = H - CONFIG.GROUND_HEIGHT;
let player = { x: CONFIG.PLAYER.x, y: groundY - CONFIG.PLAYER.h, w: CONFIG.PLAYER.w, h: CONFIG.PLAYER.h, vy:0, grounded:true };
let prevPlayerBottom = player.y + player.h;
let obstacles = [];
let frames = 0; let distance = 0; let gameState = 'menu';
let highscore = Number(localStorage.getItem('retro_high_v2') || 0);

// UI refs
const startOverlay = document.getElementById('startOverlay');
const endOverlay = document.getElementById('endOverlay');
const endTitle = document.getElementById('endTitle');
const endText = document.getElementById('endText');
const highscoreEl = document.getElementById('highscore');
const distanceEl = document.getElementById('distance');
highscoreEl.textContent = 'Highscore: ' + highscore + ' m';

// Input: tap anywhere (overlay or canvas)
function globalTap(e){
  e && e.preventDefault();
  if(gameState === 'menu') { startGame(); }
  else if(gameState === 'playing') { jump(); }
  else { restartGame(); }
}
canvas.addEventListener('pointerdown', globalTap);
startOverlay.addEventListener('pointerdown', globalTap);
endOverlay.addEventListener('pointerdown', globalTap);

function jump(){ if(player.grounded){ player.vy = CONFIG.JUMP_FORCE; player.grounded = false; } }

// Spawn obstacle with scene-aware types; all sit on ground
function spawnObstacle(){
  const scene = currentScene().name;
  let ob = null;
  const spawnX = canvas.width / (window.devicePixelRatio || 1) + 60;

  if(scene === 'Straße'){
    // car: wide, low
    const w = 60 + Math.random()*80; const h = 24 + Math.random()*16;
    ob = {x: spawnX, w, h, color: '#4a4a4a', type: 'car'};
  } else if(scene === 'Schulflur'){
    // backpack/child/teacher: varied
    const variants = [ {w:36,h:54,color:'#c86f6f'}, {w:28,h:42,color:'#7aa7ff'}, {w:42,h:64,color:'#7ad68a'} ];
    const v = variants[Math.floor(Math.random()*variants.length)];
    ob = {x: spawnX, w: v.w + Math.random()*6, h: v.h + Math.random()*10, color: v.color, type:'person'};
  } else {
    // house area or generic: small crate / bush
    const w = 26 + Math.random()*36; const h = 24 + Math.random()*36;
    ob = {x: spawnX, w, h, color:'#5a4b3f', type:'crate'};
  }
  // ensure sits on ground
  ob.y = groundY - ob.h;
  obstacles.push(ob);
}

function collides(a,b){ return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h); }

function startGame(){
  obstacles = []; frames = 0; distance = 0; player.y = groundY - player.h; player.vy = 0; player.grounded = true; gameState = 'playing';
  startOverlay.style.display = 'none'; endOverlay.style.display = 'none';
}
function restartGame(){ startGame(); }

function endGame(win=false){
  gameState = win ? 'win' : 'gameover';
  endOverlay.style.display = 'flex';
  endTitle.textContent = win ? 'Ziel erreicht!' : 'Game Over';
  endText.textContent = 'Distanz: ' + Math.floor(distance) + ' m';
  if(Math.floor(distance) > highscore){ highscore = Math.floor(distance); localStorage.setItem('retro_high_v2', highscore); highscoreEl.textContent = 'Highscore: ' + highscore + ' m'; }
}

const scenes = [
  {name:'Haus', start:0, end:1200, color:'#a8d4ff'},
  {name:'Straße', start:1200, end:2600, color:'#dbeef0'},
  {name:'Schulflur', start:2600, end:4200, color:'#fff0e0'},
  {name:'Klassenzimmer', start:4200, end:CONFIG.WIN_DISTANCE || 5000, color:'#fff7d2'}
];
function currentScene(){ for(let s of scenes) if(distance>=s.start && distance < s.end) return s; return scenes[scenes.length-1]; }

function update(){
  frames++;
  if(gameState === 'playing'){
    const speed = CONFIG.START_SPEED + Math.floor(distance/500) * CONFIG.SPEED_INCREASE_PER_500M;
    distance += speed * 0.9;

    // spawn frequency
    const interval = Math.max(CONFIG.OBSTACLE_MIN_INTERVAL, CONFIG.OBSTACLE_MAX_INTERVAL - Math.floor(distance/50));
    if(frames % Math.max(18, Math.floor(interval)) === 0) spawnObstacle();

    // physics (store previous bottom to detect landing)
    prevPlayerBottom = player.y + player.h;
    player.vy += CONFIG.GRAVITY; player.y += player.vy;
    if(player.y + player.h >= groundY){ player.y = groundY - player.h; player.vy = 0; player.grounded = true; }

    // move obstacles and collision handling
    for(let i = obstacles.length-1; i>=0; i--){
      const ob = obstacles[i];
      ob.x -= speed;
      if(ob.x + ob.w < -120) obstacles.splice(i,1);

      // collision check using previous bottom to decide landing vs hit
      if(collides(player, ob)){
        const landed = (prevPlayerBottom <= ob.y + 6) && (player.vy >= 0);
        if(landed){
          // player landed on top: do NOT die, but push player down so they fall off because obstacle moves
          player.y = ob.y - player.h;
          // give a small downward velocity so player leaves the platform immediately
          player.vy = 8;
          player.grounded = false;
        } else {
          // hit from side/front -> death
          endGame(false);
        }
      }
    }

    // win condition
    if(distance >= CONFIG.WIN_DISTANCE) endGame(true);
  }
  render();
  requestAnimationFrame(update);
}

function render(){
  const cw = canvas.width; const ch = canvas.height;
  ctx.clearRect(0,0,cw,ch);

  // scene bg
  const scene = currentScene();
  ctx.fillStyle = scene.color; ctx.fillRect(0,0,cw,ch);

  // sky elements
  drawClouds();

  // ground
  ctx.fillStyle = '#3b3b3b';
  const gy = ch * (groundY / H);
  ctx.fillRect(0, gy, cw, ch - gy);

  // road stripes
  drawRoadStripe(cw, gy);

  // obstacles (draw in world coords)
  for(let ob of obstacles){
    ctx.fillStyle = ob.color; ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
    // small detail for cars
    if(ob.type === 'car'){
      ctx.fillStyle = '#222'; ctx.fillRect(ob.x + 8, ob.y + ob.h - 8, Math.max(8, ob.w/6), 6);
      ctx.fillRect(ob.x + ob.w - 18, ob.y + ob.h - 8, Math.max(8, ob.w/6), 6);
    }
  }

  // player: classic stickman (stroke head, thin limbs)
  drawPlayer();

  // HUD DOM
  distanceEl.textContent = Math.floor(distance) + ' m';
}

function drawClouds(){
  const cw = canvas.width, ch = canvas.height;
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  for(let i=0;i<4;i++){
    const x = (i*260) + ((-distance*0.2) % 320);
    const y = 40 + (i%2)*20;
    ctx.fillRect((x % cw), y, 140, 26);
  }
}

function drawRoadStripe(cw, gy){
  if(currentScene().name !== 'Straße') return;
  for(let i=0;i<30;i++){
    const tileW = Math.round(cw/14);
    ctx.fillStyle = (i%2) ? '#3a3a3a' : '#2f2f2f';
    ctx.fillRect((i*tileW - (distance % tileW)), gy + 12, tileW - 6, 18);
  }
}

function drawPlayer(){
  const scaleX = canvas.width / W; const scaleY = canvas.height / H;
  const px = player.x * scaleX; const py = player.y * scaleY; const pw = player.w * scaleX; const ph = player.h * scaleY;

  ctx.lineWidth = Math.max(2, Math.round(2 * ((scaleX+scaleY)/2)));
  ctx.strokeStyle = '#071028'; ctx.fillStyle = '#ffd166';

  // head (stroke-only)
  const headR = pw * 0.36;
  ctx.beginPath(); ctx.arc(px + pw/2, py + headR, headR, 0, Math.PI*2); ctx.stroke();

  // body line
  ctx.beginPath(); ctx.moveTo(px + pw/2, py + headR*2); ctx.lineTo(px + pw/2, py + ph - headR); ctx.stroke();

  // arms
  ctx.beginPath(); ctx.moveTo(px + pw/2 - headR, py + headR*2 + 6); ctx.lineTo(px + pw/2 + headR, py + headR*2 + 6); ctx.stroke();

  // legs
  ctx.beginPath(); ctx.moveTo(px + pw/2, py + ph - headR); ctx.lineTo(px + pw/2 - headR, py + ph); ctx.moveTo(px + pw/2, py + ph - headR); ctx.lineTo(px + pw/2 + headR, py + ph); ctx.stroke();
}

// kick off
update();

</script>
</body>
</html>
