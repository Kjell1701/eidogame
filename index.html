<!doctype html>
<html lang="de">
<head>
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TCP17SP8ZW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TCP17SP8ZW');
</script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>RetroRunner ‚Äî Mobile-first Prototype (EIDEO)</title>
  <meta name="description" content="RetroRunner ‚Äî Mobile/Tablet-first Jump-Runner Prototype f√ºr die EIDEO Schule" />
  <style>
    /* Mobile-first, fullscreen canvas app styling */
    :root{--bg:#6fb0ff;--panel:rgba(255,255,255,0.02);--accent:#ffd166;--muted:#9aa6b2}
    html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, 'Helvetica Neue', Arial;background:var(--bg);color:#071028;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}
    .app{width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center}

    /* Canvas area: keep fixed virtual resolution for predictable gameplay */
    .canvas-wrap{width:100%;max-width:1100px;aspect-ratio:16/9;position:relative}
    canvas{display:block;width:100%;height:100%;border-radius:12px;background:var(--bg);touch-action:manipulation}

    /* HUD overlay - hidden on main menu */
    .hud{position:absolute;left:0;right:0;top:10px;display:flex;flex-direction:column;align-items:center;pointer-events:none}
    .highscore{font-size:12px;color:#071028;opacity:0.95;margin-bottom:6px;background:rgba(255,255,255,0.85);padding:4px 10px;border-radius:999px}
    .distance{font-weight:800;font-size:28px;letter-spacing:1px;color:#071028;background:rgba(255,255,255,0.9);padding:8px 16px;border-radius:999px}

    /* Start/Overlay screens */
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;padding:20px}
    .start-top{position:absolute;top:18px;left:0;right:0;display:flex;flex-direction:column;align-items:center;pointer-events:none}
    .title{font-size:20px;font-weight:800;margin:0;color:#071028}
    .subtitle{font-size:12px;opacity:0.95;margin-top:4px;color:#071028}
    .start-bottom{position:absolute;left:0;right:0;bottom:18px;display:flex;align-items:center;justify-content:center;gap:10px}
    .start-prompt{color:#071028;background:rgba(255,255,255,0.9);padding:8px 14px;border-radius:999px;font-weight:700}
    .menu-btn{background:rgba(255,255,255,0.95);padding:8px 14px;border-radius:999px;font-weight:700;color:#071028;border:0}
    .menu-controls{display:flex;gap:8px;align-items:center}

    .mid-panel{background:rgba(255,255,255,0.95);padding:12px 18px;border-radius:12px;text-align:center;color:#071028}

    /* small home button during gameplay */
    .home-btn{position:absolute;top:10px;right:10px;width:38px;height:38px;border-radius:10px;background:rgba(255,255,255,0.95);display:flex;align-items:center;justify-content:center;box-shadow:0 4px 10px rgba(0,0,0,0.12);font-size:18px;cursor:pointer;pointer-events:auto}

    /* menu highscore (visible on menu) */
    .menu-highscore{position:absolute;top:14px;right:14px;background:rgba(255,255,255,0.95);color:#071028;padding:6px 10px;border-radius:999px;font-size:12px;pointer-events:none}

    @media (min-width:900px){ .canvas-wrap{max-width:900px} }
  </style>
</head>
<body>
  <div class="app">
    <div class="canvas-wrap">
      <canvas id="game"></canvas>

      <!-- HUD (hidden on initial menu & first-tap message) -->
      <div class="hud" id="hud" style="display:none">
        <div class="highscore" id="highscore">Highscore: 0 m</div>
        <div class="distance" id="distance">0 m</div>
      </div>

      <!-- menu highscore (minimal, visible on main menu) -->
      <div id="menuHighscore" class="menu-highscore" style="display:none">Best: 0 m</div>

      <!-- small home button (hidden until playing) -->
      <div id="homeBtn" class="home-btn" style="display:none" title="Zur√ºck zum Men√º">üè†</div>

      <!-- MAIN MENU: only title + subtitle + "Tippe zum Starten" prompt + Infinite toggle -->
      <div id="menuOverlay" class="overlay" style="pointer-events:auto">
        <div class="start-top">
          <h1 class="title">EIDO RUNNER</h1>
          <div class="subtitle">Schulprojekt</div>
        </div>
        <div class="start-bottom">
          <div class="menu-controls">
            <div class="start-prompt">Tippe zum Starten</div>
            <button id="infiniteToggle" class="menu-btn">Infinite</button>
          </div>
        </div>
      </div>

      <!-- SECOND STEP overlay: shows after first tap, before game starts -->
      <div id="prestartOverlay" class="overlay" style="display:none;pointer-events:auto">
        <div class="mid-panel">
          <div style="font-weight:800;font-size:16px">Erreiche das Klassenzimmer</div>
          <div style="height:8px"></div>
          <div class="small" style="font-weight:700">Tippe zum Fortfahren</div>
        </div>
      </div>

      <!-- END overlay: shows on game over / win -->
      <div id="endOverlay" class="overlay" style="display:none;pointer-events:auto">
        <div class="mid-panel" id="endPanel">
          <h2 id="endTitle" style="margin:0">Game Over</h2>
          <p id="endText" style="margin:6px 0;font-size:14px">Distanz: 0 m</p>
          <div class="small" style="font-weight:700">Tippe auf den Bildschirm, um zu starten</div>
        </div>
      </div>

    </div>
  </div>

<script>
// ------------------------------------------------------
// RetroRunner ‚Äî Mobile UX with Infinite mode (fixed)
// - Fixed: Infinite toggle will NOT trigger the "tap-to-start" because pointerdown on the button stops propagation.
// - Added: menu highscore visible on main menu.
// - Infinite mode truly disables the win-condition check and speed continues to scale with distance.
// ------------------------------------------------------

// Virtual world resolution (fixed for consistent behavior)
const W = 900, H = 450;
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// keep logical size fixed
canvas.width = W; canvas.height = H;

// DOM refs
const hud = document.getElementById('hud');
const menuOverlay = document.getElementById('menuOverlay');
const prestartOverlay = document.getElementById('prestartOverlay');
const endOverlay = document.getElementById('endOverlay');
const endTitle = document.getElementById('endTitle');
const endText = document.getElementById('endText');
const highscoreEl = document.getElementById('highscore');
const distanceEl = document.getElementById('distance');
const infiniteToggle = document.getElementById('infiniteToggle');
const homeBtn = document.getElementById('homeBtn');
const menuHighscore = document.getElementById('menuHighscore');

// CONFIG
const CONFIG = {
  START_SPEED: 4.0,
  SPEED_INCREASE_PER_500M: 0.45,
  GRAVITY: 0.8,
  JUMP_FORCE: -15,
  WIN_DISTANCE: 10000,
  GROUND_HEIGHT: 86,
  PLAYER: {x:110, w:28, h:42},
  OBSTACLE_MIN_INTERVAL: 80,
  OBSTACLE_MAX_INTERVAL: 160
};

// State
let infiniteMode = false; // toggled via menu
let groundY = H - CONFIG.GROUND_HEIGHT;
let player = { x: CONFIG.PLAYER.x, y: groundY - CONFIG.PLAYER.h, w: CONFIG.PLAYER.w, h: CONFIG.PLAYER.h, vy:0, grounded:true };
let obstacles = [];
let frames = 0; let distance = 0; let gameState = 'menu'; // menu, prestart, playing, gameover, win
let highscore = Number(localStorage.getItem('retro_high_v5') || 0);
highscoreEl.textContent = 'Highscore: ' + highscore + ' m';
menuHighscore.textContent = 'Best: ' + highscore + ' m';
menuHighscore.style.display = 'block';

// Prevent menuOverlay's pointerdown from firing when clicking the toggle.
infiniteToggle.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); e.preventDefault(); });
// handle infinite toggle UI on click (pointerdown prevented the menu tap)
infiniteToggle.addEventListener('click', (e)=>{
  e.stopPropagation();
  infiniteMode = !infiniteMode;
  infiniteToggle.textContent = infiniteMode ? 'Infinite: ON' : 'Infinite';
  infiniteToggle.style.background = infiniteMode ? 'rgba(255,240,120,0.98)' : '';
});

// home button
homeBtn.addEventListener('click', (e)=>{ e.stopPropagation(); goToMenu(); });

// input handling: anywhere tapped
function handleTap(e){
  e && e.preventDefault();
  if(gameState === 'menu'){
    // go to prestart message
    gameState = 'prestart';
    menuOverlay.style.display = 'none';
    prestartOverlay.style.display = 'flex';
    // HUD remains hidden until actual play
    return;
  }
  if(gameState === 'prestart'){
    // start the game now
    prestartOverlay.style.display = 'none';
    startGame();
    return;
  }
  if(gameState === 'playing'){
    // jump
    if(player.grounded){ player.vy = CONFIG.JUMP_FORCE; player.grounded = false; }
    return;
  }
  // if gameover or win: restart to menu
  if(gameState === 'gameover' || gameState === 'win'){
    // go back to menu
    endOverlay.style.display = 'none';
    goToMenu();
    return;
  }
}
canvas.addEventListener('pointerdown', handleTap);
menuOverlay.addEventListener('pointerdown', handleTap);
prestartOverlay.addEventListener('pointerdown', handleTap);
endOverlay.addEventListener('pointerdown', handleTap);

function goToMenu(){
  gameState = 'menu';
  menuOverlay.style.display = 'flex';
  prestartOverlay.style.display = 'none';
  endOverlay.style.display = 'none';
  hud.style.display = 'none';
  homeBtn.style.display = 'none';
  resetToMenu();
}

function resetToMenu(){
  obstacles = []; frames = 0; distance = 0;
  player.y = groundY - player.h; player.vy = 0; player.grounded = true;
  distanceEl.textContent = '0 m';
}

function startGame(){
  hud.style.display = 'flex';
  obstacles = []; frames = 0; distance = 0;
  player.y = groundY - player.h; player.vy = 0; player.grounded = true;
  gameState = 'playing';
  homeBtn.style.display = 'flex';
}

function spawnObstacle(){
  const scene = currentScene().name;
  let ob = null;
  const spawnX = W + 60;
  if(scene === 'Stra√üe'){
    // car: wide, low
    const w = 60 + Math.random()*80; const h = 22 + Math.random()*10;
    ob = {x: spawnX, w, h, color: '#4a4a4a', type: 'car'};
  } else if(scene === 'Schulflur'){
    // backpack/person: moderate height but not too tall
    const variants = [ {w:36,h:48,color:'#c86f6f'}, {w:30,h:46,color:'#7aa7ff'}, {w:38,h:52,color:'#7ad68a'} ];
    const v = variants[Math.floor(Math.random()*variants.length)];
    ob = {x: spawnX, w: v.w + Math.random()*4, h: v.h + Math.random()*6, color: v.color, type:'person'};
  } else {
    // crate / bush
    const w = 28 + Math.random()*34; const h = 22 + Math.random()*22;
    ob = {x: spawnX, w, h, color:'#5a4b3f', type:'crate'};
  }
  // ensure sits on ground
  ob.y = groundY - ob.h;
  obstacles.push(ob);
}

function collides(a,b){ return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h); }

function endGame(win=false){
  gameState = win ? 'win' : 'gameover';
  endOverlay.style.display = 'flex';
  endTitle.textContent = win ? 'Ziel erreicht!' : 'Game Over';
  endText.textContent = 'Distanz: ' + Math.floor(distance) + ' m';
  if(Math.floor(distance) > highscore){ highscore = Math.floor(distance); localStorage.setItem('retro_high_v5', highscore); highscoreEl.textContent = 'Highscore: ' + highscore + ' m'; menuHighscore.textContent = 'Best: ' + highscore + ' m'; }
  homeBtn.style.display = 'none';
}

const scenes = [
  {name:'Haus', start:0, end:1200, color:'#6fb0ff'},
  {name:'Stra√üe', start:1200, end:5500, color:'#95d3b8'},
  {name:'Schulflur', start:5500, end:8500, color:'#ffe6c7'},
  {name:'Klassenzimmer', start:8500, end:CONFIG.WIN_DISTANCE || 5000, color:'#f7f1c6'}
];
function currentScene(){ for(let s of scenes) if(distance>=s.start && distance < s.end) return s; return scenes[scenes.length-1]; }

// Main loop
function update(){
  frames++;
  if(gameState === 'playing'){
    // speed scales without hard cap (infinite mode will keep going faster)
    const speed = CONFIG.START_SPEED + (distance/500) * CONFIG.SPEED_INCREASE_PER_500M;
    distance += speed * 0.9;

    // spawn frequency scales with distance
    const interval = Math.max(CONFIG.OBSTACLE_MIN_INTERVAL, CONFIG.OBSTACLE_MAX_INTERVAL - Math.floor(distance/50));
    if(frames % Math.max(40, Math.floor(interval)) === 0) spawnObstacle();

    // physics
    player.vy += CONFIG.GRAVITY; player.y += player.vy;
    if(player.y + player.h >= groundY){ player.y = groundY - player.h; player.vy = 0; player.grounded = true; }

    // move obstacles and check collisions (any collision -> death)
    for(let i = obstacles.length-1; i>=0; i--){
      const ob = obstacles[i];
      ob.x -= speed;
      if(ob.x + ob.w < -120) obstacles.splice(i,1);

      if(collides(player, ob)){
        // any overlap is considered a hit -> Game Over
        endGame(false);
      }
    }

    // win (only if not infinite mode)
    if(!infiniteMode && distance >= CONFIG.WIN_DISTANCE) endGame(true);
  }
  render();
  requestAnimationFrame(update);
}

function render(){
  // draw to logical canvas W x H
  ctx.clearRect(0,0,W,H);

  if(gameState === 'menu' || gameState === 'prestart'){
    // MAIN MENU and prestart should be clean: only flat background color (no clouds, no ground, no player)
    ctx.fillStyle = '#6fb0ff'; ctx.fillRect(0,0,W,H);
    return;
  }

  // background: fresh scene color
  const scene = currentScene(); ctx.fillStyle = scene.color; ctx.fillRect(0,0,W,H);

  // simple skyline/clouds
  drawClouds();

  // ground
  ctx.fillStyle = '#3b3b3b'; ctx.fillRect(0, groundY, W, H - groundY);

  // road stripes for Stra√üe
  if(scene.name === 'Stra√üe') drawRoadStripe();

  // obstacles
  ctx.save();
  for(let ob of obstacles){
    ctx.fillStyle = ob.color; ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
    if(ob.type === 'car'){
      ctx.fillStyle = '#222'; ctx.fillRect(ob.x + 8, ob.y + ob.h - 8, Math.max(8, ob.w/6), 6);
      ctx.fillRect(ob.x + ob.w - 18, ob.y + ob.h - 8, Math.max(8, ob.w/6), 6);
    }
  }
  ctx.restore();

  // player: classic stickman (stroke head, thin limbs)
  drawPlayer();

  // HUD DOM (only visible during playing)
  if(hud.style.display !== 'none'){
    distanceEl.textContent = Math.floor(distance) + ' m';
  }
}

function drawClouds(){ ctx.fillStyle = 'rgba(255,255,255,0.12)'; for(let i=0;i<3;i++){ ctx.fillRect(((i*260) - (distance*0.18 % 260)), 36 + (i%2)*18, 120, 22); } }
function drawRoadStripe(){ for(let i=0;i<30;i++){ const tileW = Math.round(W/14); ctx.fillStyle = (i%2) ? '#3a3a3a' : '#2f2f2f'; ctx.fillRect((i*tileW - (distance % tileW)), groundY + 10, tileW - 6, 16); } }

function drawPlayer(){
  // draw stickman in world coords
  const px = player.x; const py = player.y; const pw = player.w; const ph = player.h;
  ctx.lineWidth = 3; ctx.strokeStyle = '#071028'; ctx.fillStyle = '#ffd166';
  const headR = pw * 0.36;
  // head (stroke only)
  ctx.beginPath(); ctx.arc(px + pw/2, py + headR, headR, 0, Math.PI*2); ctx.stroke();
  // body
  ctx.beginPath(); ctx.moveTo(px + pw/2, py + headR*2); ctx.lineTo(px + pw/2, py + ph - headR); ctx.stroke();
  // arms
  ctx.beginPath(); ctx.moveTo(px + pw/2 - headR, py + headR*2 + 6); ctx.lineTo(px + pw/2 + headR, py + headR*2 + 6); ctx.stroke();
  // legs
  ctx.beginPath(); ctx.moveTo(px + pw/2, py + ph - headR); ctx.lineTo(px + pw/2 - headR, py + ph); ctx.moveTo(px + pw/2, py + ph - headR); ctx.lineTo(px + pw/2 + headR, py + ph); ctx.stroke();
}

// kick off loop
update();

</script>
</body>
</html>
